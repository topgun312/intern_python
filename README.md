# О проекте:
1. Реализовать свой двусвязный спискок.
Объявить класс LinkedList со следующим набором методов:

- add_obj(self, obj) - добавление нового объекта obj окласса ObjList в конец связного списка;
- remove_obj(self) - удаление последнего объекта из связного списка;
- get_data(self) - получение списка из строк локального свойства _да{а всех объектов связного списка.

И вкаждом объекте этого класса должны создаваться локальные публичные атрибуты:

- head - ссылка на первый объект связного списка (если список пустой, то head = None);
- tail - ссылка на последний объект связного списка (если список пустой, то tail = None).

Объекты класса ObjList должны иметь следующий набор приватных локальных свойств:

- __next- ссылка на следующий объект связного списка (если следующего объекта нет, то __next = None);
- __prev - ссылка на предыдущий объект связного списка (если предыдущего объекта нет, то __prev = None);
- __data - строка с данными.

Также в классе ObjList должны быть реализованы следующие сеттеры и геттеры:

- set_next(self, obj) - изменение приватного свойства __next на значение obj;
- set_prev(self, obj) - изменение приватного свойства __prev на значение obj;
- get_next(self) - получение значения приватного свойства __next;
- get_prev - получение значения приватного свойства __prev;
- set_data(self, data) - изменение приватного свойства __data на значение data;
- get_data(self) - получение значения приватного свойства __data.


2. Реализовать игру «Сапер» (с помощью двух классов) в консоли.

Cell - для представления клетки игрового поля;
GamePole - для управления игровым полем, размером N х N клеток.

В каждом объекте класса Cell должны создаваться локальные свойства:

- around_mines- число мин вокруг клетки (начальное значение 0);
- mine - наличие/отсутствие мины в текущей клетке (True/False);
- fl_open - открыта/закрыта клетка - булево значение (True/False). Изначально все клетки закрыты (False).

С помощью класса GamePole должна быть возможность создавать квадратное игровое поле с числом клеток N х N:

Здесь N - размер поля; М - общее число мин на поле. При этом, каждая клетка представляется объектом класса Cell и все объекты
хранятся в двумерном списке N х N элементов - локальном свойстве рае объекта класса GamePole.

В классе GamePole должны быть также реализованы следующие методы:

- init() - инициализация поля с новой расстановкой М мин (случайным образом по игровому полю, разумеется каждая мина должна находиться в отдельной клетке).
- show() - отображение поля в консоли в виде таблицы чисел открытых клеток (если клетка не открыта, то отображается символ #; мина отображается символом *; между клетками при отображении ставить пробел).

При создании экземпляра класса GamePole в его инициализаторе следует вызывать метод init() для первоначальной инициализации игрового поля.
В классе GamePole могут быть и другие вспомогательные методы.

3. Реализовать простую имитацию локальной сети, состоящую из набора серверов, соединенных между собой через роутер.

Каждый сервер может отправлять пакет любому другому серверу сети. Для этого у каждого есть свой уникальный IP-адрес. Для
простоты - это просто целое (натуральное) число от 1 и до N, где N - общее число серверов. Алгоритм следующий. Предположим,
сервер с IP = 2 собирается отправить пакет информации серверу с IP = 3. Для этого, он сначала отправляет пакет роутеру, а уже тот, 
смотрит на IP-адрес и пересылает пакет нужному узлу (серверу).

Для реализации этой схемы программе предлагается объявить три класса:

- Server - для описания работы серверов в сети;
- Router - для описания работы роутеров в сети (в данной задаче полагается один роутер);
- Data - для описания пакета информации.

Серверы будут создаваться командой:

- sv = Server()

При этом, уникальный IP-адрес каждого сервера должен формироваться автоматически при создании нового экземпляра класса Server
Далее, роутер должен создаваться аналогичной командой:

- router = Router()

А, пакеты данных, командой:
data = Data(строка с данными, IP-адрес назначения)

Для формирования и функционирования локальной сети, в классе Router должны быть реализованы следующие методы:

- link(server) - для присоединения сервера server (объекта класса Server) к роутеру (для простоты, каждый сервер соединен только с
одним роутером);
- unlink(server) - для отсоединения сервера server (объекта класса Server) от роутера;
- send_data() - для отправки всех пакетов (объектов класса Data) из буфера роутера соответствующим серверам (после отправки буфер
должен очищаться).

И одно обязательное локальное свойство (могут быть и другие свойства):

- buffer - список для хранения принятых от серверов пакетов (объектов класса Data).

Класс Server должен содержать свой набор методов:

- send_data(data) - для отправки информационного пакета data (объекта класса Data) с указанным IP-адресом получателя (пакет
отправляется роутеру и сохраняется в его буфере - локальном свойстве buffer);
- get_data() возвращает список принятых пакетов (если ничего принято не было, то возвращается пустой список) и очищает входной буфер;
- get_ip() - возвращает свой IP-адрес.

Соответственно в объектах класса Server должны быть локальные свойства:

- buffer - список принятых пакетов (объекты класса Data, изначально пустой);
- ip - IP-адрес текущего сервера.

Наконец, объекты класса Data должны содержать два следующих локальных свойства:

- data - передаваемые данные (строка);
- ip -IP-адрес назначения.

